## 동적 계획법(Dynammic Programming)
### DP란 ?
- 메모리 공간을 약간 더 사용하면서 연산속도를 비약적으로 증가시킬 수 있는 기법이다.
- 이미 계산된 결과(작은 문제)는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 한다.
- 구현은 일반적으로 탑다운(top-down)방식과 바텀업(bottom-up)방식이 존재한다.
<br>

### 조건 
- 큰 문제를 작은 문제로 나눌 수 있고 그 작은 문제의 답을 모아서 큰 문제를 해결할 수 있는 경우
- 동일한 작은 문제를 반복적으로 해결해야하는 경우

<br>

### 메모이제이션(Memoization)
- 다이나믹 프로그래밍을 구현하는 방법 중 하나로서, 한 번 계산한 결과를 메모리 공간에 메모하는 기법이다.
    - 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져온다.
    - 값을 기록해 놓는다는 점에서 캐싱이라고도 한다.
- 메모이제이션은 한 번 구한 정보를 리스트에 저장하는 형태로 구현할 수 있다.
    - 이 리스트를 보통 DP테이블이라고 부른다. 
  
<br>

### bottom_up vs top_down 비교 
- 탑다운 방식은 재귀함수로 구현할 수 있고, 보텀업 방식은 반복문으로 구현할 수 있다.
- 다이나믹 프로그래밍의 전형적인 형태는 보텀업 방식이다.
- 뭐가 더 좋은지는 문제마다 다르다. 하지만 일반적으로 재귀함수를 사용하는 것 보다 반복문을 사용하는 것이 성능이 좀 더 좋다(오버헤드가 줄기 때문에). 시간 복잡도 측면에서는 동일하다.
- 따라서 특정 케이스를 제외하고는 그냥 자신이 편한걸로 쓰면 된다.
<br>

### EXAMPLE :
```python
# bottom_up 방식
d = [0] * 100

d[1] = 1
d[2] = 1
n = 10

for i in range(3, n + 1):
    d[i] = d[i - 1] + d[i - 2]

print(d[n])
```

```python
# top_down 방식
d = [0] * 100

def fibo(x) :
    if x == 1 or x ==2 :
        return 1

    if d[x] != 0:
        return d[x]

    d[x] = fibo(x-1) + fibo(x-2)
    return d[x]

print(fibo(4))
```



