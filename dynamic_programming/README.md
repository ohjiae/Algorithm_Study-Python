## 동적 계획법(Dynammic Programming)
### DP란 ?
- 메모리 공간을 약간 더 사용하면서 연산속도를 비약적으로 증가시킬 수 있는 기법이다.
- 이미 계산된 결과(작은 문제)는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 한다.
- 구현은 일반적으로 탑다운(top-down)방식과 바텀업(bottom-up)방식이 존재한다.
<br>

### 조건 
- 큰 문제를 작은 문제로 나눌 수 있고 그 작은 문제의 답을 모아서 큰 문제를 해결할 수 있는 경우
- 동일한 작은 문제를 반복적으로 해결해야하는 경우

<br>

### 메모이제이션(Memoization)
- 다이나믹 프로그래밍을 구현하는 방법 중 하나로서, 한 번 계산한 결과를 메모리 공간에 메모하는 기법이다.
    - 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져온다.
    - 값을 기록해 놓는다는 점에서 캐싱이라고도 한다.
- 메모이제이션은 한 번 구한 정보를 리스트에 저장하는 형태로 구현할 수 있다.
    - 이 리스트를 보통 DP테이블이라고 부른다. 
  
<br>

### bottom_up vs top_down 비교 
- 탑다운 방식은 재귀함수로 구현할 수 있고, 보텀업 방식은 반복문으로 구현할 수 있다.
- 다이나믹 프로그래밍의 전형적인 형태는 보텀업 방식이다.
- 뭐가 더 좋은지는 문제마다 다르다. 하지만 일반적으로 재귀함수를 사용하는 것 보다 반복문을 사용하는 것이 성능이 좀 더 좋다(오버헤드가 줄기 때문에). 시간 복잡도 측면에서는 동일하다.
- 따라서 특정 케이스를 제외하고는 그냥 자신이 편한걸로 쓰면 된다.
<br>

### EXAMPLE :
```python
# bottom_up 방식
d = [0] * 100

d[1] = 1
d[2] = 1
n = 10

for i in range(3, n + 1):
    d[i] = d[i - 1] + d[i - 2]

print(d[n])
```

```python
# top_down 방식
d = [0] * 100

def fibo(x) :
    if x == 1 or x ==2 :
        return 1

    if d[x] != 0:
        return d[x]

    d[x] = fibo(x-1) + fibo(x-2)
    return d[x]

print(fibo(4))
```

<br><br>

### BOJ - 1915 가장 큰 정사각형 (문제풀이)
```python
import sys
input = sys.stdin.readline

n,m = map(int, input().split())
arr = []
dp = [[0] * m for _ in range(n)]
ans = 0

for _ in range(n) :
    arr.append(list(map(int,input().rstrip())))

for i in range(n):
    for j in range(m):
        if i == 0 or j == 0:  # 사각형 외각
            dp[i][j] = arr[i][j]
        elif arr[i][j] == 0:  # 값이 0일 경우
            dp[i][j] = 0
        else:
            dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1 #사각형의 외각이 아니고, 내부의 값이 1일 경우
        ans = max(dp[i][j], ans)

print(ans * ans)
```
<br>

### 풀이 : 
```dp```를 활용해서 정사각형을 판별하는 것이 어려웠다. 다른 반례들도 보고 내 코드를 수정하면서 이틀만에 풀게 되었다. 
처음에 생각한 방법은 재귀적인 방법이였다. 이중 ```for```문으로 크기가 ```1```인경우, ```2```인경우, ... ```n```인경우를 모두 구하려고 했었다.
이러한 방식을 이용해 ```top-down```방식으로 문제를 해결하려고 하였으나, ```n```이 커질수록 모든 경우를 구하는게 어려웠다. 
또 다른 방법은 정사각형내에 ```1```이 존재하면 대각선의 값을 모두 탐색하는(아주 비효율적인) 방법이 생각나서 바로 접었다. 
그러다가 다른 사람들의 접근 방식을 참조하여 힌트를 얻었고, 아래와 같이 해결하였다. (대부분 이러한 방식을 사용한 듯 하였다.)
<br>

```n```과 ```m```을 입력받고 ```n```행```m```열 크기만큼 2차원 리스트 ```dp```를 ```0```으로 초기화한다. 
```python
[[0, 0, 0, 0]]
[[0, 0, 0, 0]]
[[0, 0, 0, 0]]
[[0, 0, 0, 0]]
```
<br>

```for```문을 이용하여 ```n```번만큼 빈 리스트인 ```arr```에 값을 삽입시킨다. ```input()```으로 들어온 값을 ```rstrip()```을 이용하여 오른쪽 공백을 제거 후 ```map()```을 통해 정수로 바꿔주고,
```list(ex : 0001의 경우 [0,0,0,1] )```로 만들어서 ```arr```에 값을 추가하면 2차원 리스트로 초기화된다.
```python
[[0,1,0,0]]
[[0,1,1,1]]
[[1,1,1,0]]
[[0,0,1,0]]
```
<br>

```if i == 0 or j == 0: ``` 에서 사각형의 외각의 값을 dp에 저장한다. 그리고 ```elif arr[i][j] == 0:```에서 사각형 내부의 값이 ```0```일 경우 ```dp[i][j]```값을 0으로 초기화한다. ```else```문에서 ```min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1```를 수행한다. 
```python
[[0,1,0,0]]
[[0,1,1,1]]
[[1,1,1,0]]
[[0,0,1,0]]
```
그리고 ```ans```에 현재 저장되어 있는 값과 현재 ```dp[i][j]```값 중에 가장 큰 값을 저장한다.

<br><br>


### EX : 
```python
[[1,1]]
[[0,1]]
```
```(0,0) = 1, (0,1) = 1, (1,0) = 0``` 이다. ```min(1,1,0)```은 ```0```이고, 거기에 ```1```을 더해준다면, ```0 + 1 = 1```이다. 가장 최소인 값의 ```+ 1```이 해당 인덱스의 가장 오른쪽 아래 값일 경우 최대 크기의 정사각형이다. 하지만, 위의 경우에는 ```0 + 1 = 1```이라서 정사각형의 조건을 만족하지 못한다. **반대로 ```min(1,1,1)```은 ```1```이고, ```1```을 더하였을 때 ```2```가 된다면 정사각형이 된다.**
